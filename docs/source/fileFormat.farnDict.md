# farnDict

## Description

A farnDict is a file in dictIO dict file format used with farn

A farnDict
* defines the layers, the parameters varied per layer and the related sampling used to create the samples per layer
* after sampling, the layers, parameters and generated samples per layer make up the designspace that farn traverses
* farn creates one distinct case folder for each sample, making up a nested case folder structure
* nest levels and -dimensions of the case folder structure follow the sequence of layers as defined in the farn dict

## Elements

| element / key                             | type                          | Description |
| :-----------------------------------------| :---------------------------- | :---------- |
| _environment                              | dict                          | [optional] dict with system variables set at runtime, commonly containing folder paths, which can subsequently be referenced in shell commands defined in _commands |
| _layers                                   | dict                          | dict defining all layers. Each layer represents one nest level in the folder structure that will be generated by farn. |
| &numsp;\<LAYER>                           | dict                          | unique key defining a layer. It serves as basename for all case folders in the nest level corresponding with that layer. |
| &numsp;&numsp;_sampling                   | dict                          | dict defining sampling-type and -parameters of a layer |
| &numsp;&numsp;&numsp;_type                | string                        | sampling type. Choices currently implemented are {'fixed', 'linSpace', 'uniformLhs'} |
| &numsp;&numsp;&numsp;_names               | list[string]                  | list naming all variables / parameters being varied in this layer. For each variable / parameter named here, sampled values will be generated. |
| &numsp;&numsp;&numsp;_values              | list[list[*float]]            | (required for sampling type 'fixed'): List containing lists of fixed values. For each parameter name defined in _names, one list of fixed values must exist, i.e. the number of lists in _values must match the number of parameter names defined in _names. The number of values can freely be chosen. However, all lists in _values must have the same number of values. |
| &numsp;&numsp;&numsp;_ranges              | list[list[float,&nbsp;float]] | (required for sampling types 'linSpace' and 'uniformLhs'): List containing ranges. A range is defined through the lower and upper boundary value for the related parameter name, given as tuple (minimum, maximum). For each parameter name defined in _names, one range tuple must exist. |
| &numsp;&numsp;&numsp;_numberOfSamples     | int                           | (required for sampling types 'linSpace' and 'uniformLhs'): Number of samples to be generated. In case of 'linSpace', boundary values are included if an odd number of samples is given. In case of 'uniformLHS', the given number of samples will be generated within range (=between lower and upper boundary), excluding the boundaries themselves. |
| &numsp;&numsp;&numsp;_includeBoundingBox  | bool                          | (optional, for sampling type 'uniformLhs'): Defines whether the lower and upper boundary values of each parameter name shall be added as additional samples. If missing, defaults to FALSE. |
| &numsp;&numsp;_condition                  | dict                          | (optional) a condition allows to define a filter expression to include or exclude specific samples. |
| &numsp;&numsp;&numsp;_filter              | string                        | filter expression in a pandas-like stype |
| &numsp;&numsp;&numsp;_action              | string                        | (optional) defines the action triggered when the filter expression evaluates to True. Choices: 'include', 'exclude'. If missing, defaults to 'exclude'. |
| &numsp;&numsp;_samples                    | dict                          | dict containing all samples. The '_samples' section of a layer is generated by farn when run with option --sample. |
| &numsp;&numsp;_commands                   | dict                          | (optional) dict defining commandsets that can be executed in a layer. |
| &numsp;&numsp;&numsp;\<COMMAND>           | list[string]                  | unique key defining a command element. A command element contains one or more shell commands, saved as a list of strings. When farn is called with -e \<COMMAND> argument, all shell commands listed in \<COMMAND> will be executed in the given sequence, in all case folders corresponding to the layer the command element is defined in. |

## Example

Below example shows a typical farnDict file.
In the example, a 6-dimensional design space is spawned, organised in 4 layers:
1.  'gp'        level 0     (root layer)    no. of parameters: 1    sampling: fixed      (Example 'gp' indicating e.g. a hypothetical grid parameter)
2.  'lhsvar'    level 1     (nested layer)  no. of parameters: 3    sampling: uniformLhs (Example  3 dimensional sub design space, LHS sampled)
3.  'cp'        level 2     (nested layer)  no. of parameters: 1    sampling: linSpace   (Example 'cp' indicating e.g. a hypothetical compute parameter (solver setting, version whatever))
4.  'mp'        level 3     (leaf layer)    no. of parameters: 1    sampling: fixed      (Example 'mp' indicating e.g. a hypothetical multiplier for an internal variable)
~~~js
/*---------------------------------*- C++ -*----------------------------------*\
filetype dictionary; coding utf-8; version 0.1; local --; purpose --;
\*----------------------------------------------------------------------------*/
_environment
{
    CASEDIR                   cases;
    DUMPDIR                   dump;
    LOGDIR                    logs;
    RESULTDIR                 results;
    TEMPLATEDIR               template;
}
_layers
{
    gp                                          // unique key defining a layer. Will be used by farn as basename for all case folders in the corresponding nest level.
    {
        _sampling
        {
            _type fixed;                        // Fixed values. Note: Each sampling type has its own set of required arguments.
            _names(mpGrid);                     // list with names, each representing one variable or parameter.
            _values((0.9 1.3));                 // list containing list with fixed values, one list for each parameter name. Required for sampling type 'fixed'.
        }
    }
    lhsvar
    {
        _sampling
        {
            _type uniformLhs;                   // Latin-Hypercube-Sampling. Future options might also include normallhs, lognormlhs etc. (currently not implemented)
            _names(param1 param2 param3);
            _ranges((-10 10)(0 3.5)(0 1.1));    // list containing ranges. A range is defined through the lower and upper boundary value for the related parameter name, given as tuple (minimum, maximum). For each parameter name, one range tuple must exist.
            _includeBoundingBox True;           // [optional] defines whether the lower and upper boundary values of each parameter name shall be added as additional samples. If missing, defaults to False.
            _numberOfSamples 100;               // number of samples to be generated. The given number of samples will be generated within range (=between lower and upper boundary), excluding the boundaries themselves.
        }
    }
    cp
    {
        _sampling
        {
            _type linSpace;                     // Linearly spaced sampling.
            _names(relFactor);
            _ranges((0.5 0.8));
            _numberOfSamples 5;
        }
        _condition                              // a condition allows to define a filter expression to include or exclude specific samples.
        {
            _filter  'param2 >= param3 and param1 >= 0'; // filter expression.
            _action  exclude;                            // [optional] defines the action triggered when the filter expression evaluates to True. choices: 'include', 'exclude'. If missing, defaults to 'exclude'.
        }
    }
    mp
    {
        _sampling
        {
            _type fixed;
            _names(cpMul ppMul);                // (just exemplary parameter names. Imagine e.g. be multipliers for solver and postprocessing.)
            _values((1.5 2.0 3.5)(1.5 2.0 3.5));
        }
        _commands                               // commands. Each <COMMAND> element contains a list with one or more shell commands.
        {
            prepare                             // command 'prepare' (contains 3 shell commands)
                (
                    'copy %TEMPLATEDIR%/caseDict'   // shell command 1
                    'rem parsed.caseDict'           // shell command 2
                    'dictParser --quiet caseDict'   // shell command 3
                );
            run                                 // command 'run' (contains 1 shell command)
                (
                    'cosim.exe run OspSystemStructure.xml -b 0 -d 20 --real-time -v'
                );
        }
    }
}
~~~

## Filtering

Generic filtering is possible via the _condition statement. The validity of the _condition statement is proved on every farn run, regardeless of the given farn option --sample. --generate or --execute.
However it makes a difference whether --sample, --generate or --execute was given in combination with a valid present filter expression, see below.
The general
### Structure
is
~~~js
_condition
{
    _filter  FILTER_EXPRESSION;
    _action  STATEMENT;
}
~~~
Each statement is a one-off; a level can only contain one _condition and a _condition can only contain one _filter or one _action.
Where the
### Filter expression
using "_filter ARGUMENT" is a string, containing a relational statement or list comparison, e.g:
* 'param1 > 3'                                    : with param1 an user defined key within the current scope (farn level)
* "param1 < 0 or param2 == 1"                     : with param1 & param2 keys within current level combined with boolean expressions "and, "or" and "not"
* "param1 * sqrt(param2)"                         : with param1 & param2 keys within current level in combination with mathematical opertors and constants
* "param1 in [4, 5, 7]"                           : with param1 list comparison
* "RESERVED_KEYWORD not in ['case_00', case_01']" : with RESERVED_KEYWORD, an available variable during runtime, see below.
* or any combination of the statements above.

The subsequent
### Action
to take using "_action STATEMENT" can currently be one of the following:
* include or
* exclude.
The default action is "exclude": this is being applied if the key _exclude was omitted.

Farn proves the validity of the _filter expression and sets the validity flag for the regarding case to wheter true or false, depending on users input.
### Combination with farn options
* --sample option given and filter expression given   : cases appear or disappear in _samples section withing sampled.farnDict and are available|unavailable from the beginning.
* --generate option given and filter expression given : cases will be generated or not depending on the given _action statement.
* --execute option given and filter expression given  : cases will be executed or not depending on the given _action statement.
Filter expression can be modified during the whole farn process whenever needed by changing the sampled.farnDict.
If a filter expression was deactivated or mitigated somewhere in between --generate and --execute, farn throws a warning mentioning that the case was not generated.
### Applying filter expression out-of-scope
If a given filter expression is not (yet) in the current scope (farn level), the validation (prove) is stopped and no action is taken, hence the case is valid (default).
### Reserved keywords
can be one of the following list: {'case_name', 'command_sets', 'condition', 'index', 'is_leaf', 'layer', 'level', 'no_of_samples', 'path'}.
They are available during runtime (when the current farn level is processed).
If unsure, elevating farn's log-level from INFO to DEBUG give a list of available keywords.
The benefit of this approach is the application of subsequent filtering, where the user can exclude "problem" cases afterwards by simply adating to e.g.
~~~js
_condition
{
    _filter  "index in [0, 200, 201]";
    _action  exclude;
}
~~~












